values <- tail(run_base_agg, 1)
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
tail_agg <<- tail(run_base_agg, 1)
print(round(tail_agg, digits = 3))
print(round(tail_agg[[2]], digits = 4) != 1)
if(round(tail_agg[[2]], digits = 4) != 1) {
#Identifying the order of the resistances
res_order_vec <- c(names(values[4:6])[which.max(values[4:6])],
names(values[4:6])[setdiff(1:3, c(which.min(values[4:6]), which.max(values[4:6])))],
names(values[4:6])[which.min(values[4:6])])
#Storing baseline info for the integrals
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Single Taxation
parms[["eff_tax"]][as.numeric(substr(res_order_vec[2], 2, 2)), c(1:6)] <- parms[["base_tax"]]
parms[["int_round"]] <- 1
out_run_single <- ode_wrapper(y = init, func = amr, times = seq(0, 10000), parms = parms, approx_sigma)
out_single <- out_run_single[[1]]; parms_single <- out_run_single[[2]]
#Differential Taxation
diff <- multi_int_fun(6, 365*3, parms, init, amr, agg_func, ode_wrapper, approx_sigma)
out_diff <- diff[[1]]
parms_diff <- diff[[2]]
#Integrals
integral_single <- integral(out_single, 3000, 0.5)
integral_diff <- integral(out_diff, 3000, 0.5)
reduc_usage_vec_single <- sum(usage_fun(parms_single)[,6])
reduc_usage_vec_diff <- sum(usage_fun(parms_diff)[,6])
#Store Computation Vectors
single_usage <- list((integral_single[1] - base_tot_inf)/reduc_usage_vec_single,
(base_int_res - integral_single[2])/reduc_usage_vec_single,
integral_single[3],
integral_single[4])[[outcome]]
diff_usage <- list((integral_diff[1] - base_tot_inf)/reduc_usage_vec_diff,
(base_int_res - integral_diff[2])/reduc_usage_vec_diff,
integral_diff[3],
integral_diff[4])[[outcome]]
return_vec[z] <- list(single_usage, diff_usage)[[intervention]]
} else{
return_vec[z] <- NA
}
print(paste0(round(z/nrow(x), digits  = 4)*100,"%"))
}
#Progress Bar
return(return_vec)
}
ode_function(x = data.frame(lambda = 1/365*(2),
beta = 5, sigma1 = 0.5, sigma2 = 0.5, sigma3 = 0.25,
r_wt = 1/12, r_r = 1/10,  r_rr = 1/9,  r_rrr = 1/8,
r_t = 1/7, eta_wr = 0.3, eta_rw = 0.04,
eta_rr = 0.01, eta_rrr = 0.01,
c1 = 0.945, c2 = 0.925, c3 = 0.85,
c12 = 0.845, c13 = 0.825, c23 = 0.75,
c123 = 0.7, rho = 0.05, base_tax = 0.5),
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
# Parameters for the eFAST ------------------------------------------------
factors <- c("lambda", "beta", "sigma1", "sigma2", "sigma3", "r_wt", "r_r", "r_rr", "r_rrr", "r_t",
"eta_wr", "eta_rw", "eta_rr", "eta_rrr", "c1", "c2", "c3", "c12", "c13", "c23",
"c123", "rho", "base_tax")
parm_list <- list(list(min=1/3650*(2), max=1/36.5*(2)),
list(min=0.0001, max=5), #beta
list(min=0, max= 1), #sigma1
list(min=0, max = 1), #sigma2
list(min=0, max = 1), #sigma3
list(min=0.0001, max=0.5), #r_wt
list(min=0.0001, max=0.5), #r_r
list(min=0.0001, max = 0.5), #r_rr
list(min=0.0001, max=0.5), #r_rrr
list(min=0.0001, max=0.5), #r_t
list(min=0.0001, max=1), #eta_wr
list(min=0.0001, max=1), #eta_rw
list(min=0.0001, max=1), #eta_rr
list(min=0.0001, max=1), #eta_rrr
list(min=0.5, max=1), #c1
list(min=0.5, max=1), #c2
list(min=0.5, max=1), #c3
list(min=0.5, max=1), #c12
list(min=0.5, max=1), #c13
list(min=0.5, max=1), #c23
list(min=0.5, max=1), #c123
list(min=0.0001, max=1), #rho
list(min=0.0001, max=1))
init <- c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0)
start_time <- Sys.time()
# Single ------------------------------------------------------------------
testres_single <- fast99(model = ode_function, factors = factors, n = 200,
q.arg = parm_list, #base_tax
init = init,
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
#The first Stage is to create a wrapper function for the eFAST analysis
#The purpose of this is to have a function which can be used to take in a model input and to output the exact outcome measure you are looking to explore.
ode_function <- function(x, init, parms_base, outcome, intervention, integral,
ode_wrapper, approx_sigma, multi_int_fun, usage_fun) {
return_vec <- c()
for(z in 1:nrow(x)) {
#Create the Parameters
parms = c(lambda = x[z,1],
beta = x[z,2], sigma1 = x[z,3], sigma2 = x[z,4], sigma3 = x[z,5],
r_wt = x[z,6], r_r = x[z,7],  r_rr = x[z,8],  r_rrr = x[z,9],
r_t = x[z,10], eta_wr = x[z,11], eta_rw = x[z,12],
eta_rr = x[z,13], eta_rrr = x[z,14],
c1 = x[z,15], c2 = x[z,16], c3 = x[z,17],
c12 = x[z,18], c13 = x[z,19], c23 = x[z,20],
c123 = x[z,21], base_tax = x[z,23],rho = x[z,22],
t_n = 3000, time_between = Inf, int_round = 1)
#need to rearrange the parameters here - especially sigma
if(parms["sigma1"] + parms["sigma2"] + parms["sigma3"] > 1) {
parms[c("sigma1", "sigma2", "sigma3")] <- as.list(unlist(parms[c("sigma1", "sigma2", "sigma3")])/
(sum(unlist(parms[c("sigma1", "sigma2", "sigma3")])) + runif(1, 0, 1)))
}
print(sum(as.numeric(c("sigma1", "sigma2", "sigma3"))))
parms <- as.list(parms)
parms = append(parms, parms_base["PED"])
parms = append(parms, parms_base["eff_tax"])
#Run Baseline
run_base <- ode_wrapper(y = init, func = amr, times = seq(0, 10000), parms = parms, approx_sigma)[[1]]
run_base_agg <- agg_func(run_base)
values <- tail(run_base_agg, 1)
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
tail_agg <<- tail(run_base_agg, 1)
print(round(tail_agg, digits = 3))
print(round(tail_agg[[2]], digits = 4) != 1)
if(round(tail_agg[[2]], digits = 4) != 1) {
#Identifying the order of the resistances
res_order_vec <- c(names(values[4:6])[which.max(values[4:6])],
names(values[4:6])[setdiff(1:3, c(which.min(values[4:6]), which.max(values[4:6])))],
names(values[4:6])[which.min(values[4:6])])
#Storing baseline info for the integrals
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Single Taxation
parms[["eff_tax"]][as.numeric(substr(res_order_vec[2], 2, 2)), c(1:6)] <- parms[["base_tax"]]
parms[["int_round"]] <- 1
out_run_single <- ode_wrapper(y = init, func = amr, times = seq(0, 10000), parms = parms, approx_sigma)
out_single <- out_run_single[[1]]; parms_single <- out_run_single[[2]]
#Differential Taxation
diff <- multi_int_fun(6, 365*3, parms, init, amr, agg_func, ode_wrapper, approx_sigma)
out_diff <- diff[[1]]
parms_diff <- diff[[2]]
#Integrals
integral_single <- integral(out_single, 3000, 0.5)
integral_diff <- integral(out_diff, 3000, 0.5)
reduc_usage_vec_single <- sum(usage_fun(parms_single)[,6])
reduc_usage_vec_diff <- sum(usage_fun(parms_diff)[,6])
#Store Computation Vectors
single_usage <- list((integral_single[1] - base_tot_inf)/reduc_usage_vec_single,
(base_int_res - integral_single[2])/reduc_usage_vec_single,
integral_single[3],
integral_single[4])[[outcome]]
diff_usage <- list((integral_diff[1] - base_tot_inf)/reduc_usage_vec_diff,
(base_int_res - integral_diff[2])/reduc_usage_vec_diff,
integral_diff[3],
integral_diff[4])[[outcome]]
return_vec[z] <- list(single_usage, diff_usage)[[intervention]]
} else{
return_vec[z] <- NA
}
print(paste0(round(z/nrow(x), digits  = 4)*100,"%"))
}
#Progress Bar
return(return_vec)
}
ode_function(x = data.frame(lambda = 1/365*(2),
beta = 5, sigma1 = 0.5, sigma2 = 0.5, sigma3 = 0.25,
r_wt = 1/12, r_r = 1/10,  r_rr = 1/9,  r_rrr = 1/8,
r_t = 1/7, eta_wr = 0.3, eta_rw = 0.04,
eta_rr = 0.01, eta_rrr = 0.01,
c1 = 0.945, c2 = 0.925, c3 = 0.85,
c12 = 0.845, c13 = 0.825, c23 = 0.75,
c123 = 0.7, rho = 0.05, base_tax = 0.5),
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
# Parameters for the eFAST ------------------------------------------------
factors <- c("lambda", "beta", "sigma1", "sigma2", "sigma3", "r_wt", "r_r", "r_rr", "r_rrr", "r_t",
"eta_wr", "eta_rw", "eta_rr", "eta_rrr", "c1", "c2", "c3", "c12", "c13", "c23",
"c123", "rho", "base_tax")
parm_list <- list(list(min=1/3650*(2), max=1/36.5*(2)),
list(min=0.0001, max=5), #beta
list(min=0, max= 1), #sigma1
list(min=0, max = 1), #sigma2
list(min=0, max = 1), #sigma3
list(min=0.0001, max=0.5), #r_wt
list(min=0.0001, max=0.5), #r_r
list(min=0.0001, max = 0.5), #r_rr
list(min=0.0001, max=0.5), #r_rrr
list(min=0.0001, max=0.5), #r_t
list(min=0.0001, max=1), #eta_wr
list(min=0.0001, max=1), #eta_rw
list(min=0.0001, max=1), #eta_rr
list(min=0.0001, max=1), #eta_rrr
list(min=0.5, max=1), #c1
list(min=0.5, max=1), #c2
list(min=0.5, max=1), #c3
list(min=0.5, max=1), #c12
list(min=0.5, max=1), #c13
list(min=0.5, max=1), #c23
list(min=0.5, max=1), #c123
list(min=0.0001, max=1), #rho
list(min=0.0001, max=1))
init <- c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0)
start_time <- Sys.time()
# Single ------------------------------------------------------------------
testres_single <- fast99(model = ode_function, factors = factors, n = 200,
q.arg = parm_list, #base_tax
init = init,
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
ode_function <- function(x, init, parms_base, outcome, intervention, integral,
ode_wrapper, approx_sigma, multi_int_fun, usage_fun) {
return_vec <- c()
for(z in 1:nrow(x)) {
#Create the Parameters
parms = c(lambda = x[z,1],
beta = x[z,2], sigma1 = x[z,3], sigma2 = x[z,4], sigma3 = x[z,5],
r_wt = x[z,6], r_r = x[z,7],  r_rr = x[z,8],  r_rrr = x[z,9],
r_t = x[z,10], eta_wr = x[z,11], eta_rw = x[z,12],
eta_rr = x[z,13], eta_rrr = x[z,14],
c1 = x[z,15], c2 = x[z,16], c3 = x[z,17],
c12 = x[z,18], c13 = x[z,19], c23 = x[z,20],
c123 = x[z,21], base_tax = x[z,23],rho = x[z,22],
t_n = 3000, time_between = Inf, int_round = 1)
#need to rearrange the parameters here - especially sigma
if(parms["sigma1"] + parms["sigma2"] + parms["sigma3"] > 1) {
parms[c("sigma1", "sigma2", "sigma3")] <- as.list(unlist(parms[c("sigma1", "sigma2", "sigma3")])/
(sum(unlist(parms[c("sigma1", "sigma2", "sigma3")])) + runif(1, 0, 1)))
}
print(as.numeric(c("sigma1", "sigma2", "sigma3")))
parms <- as.list(parms)
parms = append(parms, parms_base["PED"])
parms = append(parms, parms_base["eff_tax"])
#Run Baseline
run_base <- ode_wrapper(y = init, func = amr, times = seq(0, 10000), parms = parms, approx_sigma)[[1]]
run_base_agg <- agg_func(run_base)
values <- tail(run_base_agg, 1)
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
tail_agg <<- tail(run_base_agg, 1)
print(round(tail_agg, digits = 3))
print(round(tail_agg[[2]], digits = 4) != 1)
if(round(tail_agg[[2]], digits = 4) != 1) {
#Identifying the order of the resistances
res_order_vec <- c(names(values[4:6])[which.max(values[4:6])],
names(values[4:6])[setdiff(1:3, c(which.min(values[4:6]), which.max(values[4:6])))],
names(values[4:6])[which.min(values[4:6])])
#Storing baseline info for the integrals
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Single Taxation
parms[["eff_tax"]][as.numeric(substr(res_order_vec[2], 2, 2)), c(1:6)] <- parms[["base_tax"]]
parms[["int_round"]] <- 1
out_run_single <- ode_wrapper(y = init, func = amr, times = seq(0, 10000), parms = parms, approx_sigma)
out_single <- out_run_single[[1]]; parms_single <- out_run_single[[2]]
#Differential Taxation
diff <- multi_int_fun(6, 365*3, parms, init, amr, agg_func, ode_wrapper, approx_sigma)
out_diff <- diff[[1]]
parms_diff <- diff[[2]]
#Integrals
integral_single <- integral(out_single, 3000, 0.5)
integral_diff <- integral(out_diff, 3000, 0.5)
reduc_usage_vec_single <- sum(usage_fun(parms_single)[,6])
reduc_usage_vec_diff <- sum(usage_fun(parms_diff)[,6])
#Store Computation Vectors
single_usage <- list((integral_single[1] - base_tot_inf)/reduc_usage_vec_single,
(base_int_res - integral_single[2])/reduc_usage_vec_single,
integral_single[3],
integral_single[4])[[outcome]]
diff_usage <- list((integral_diff[1] - base_tot_inf)/reduc_usage_vec_diff,
(base_int_res - integral_diff[2])/reduc_usage_vec_diff,
integral_diff[3],
integral_diff[4])[[outcome]]
return_vec[z] <- list(single_usage, diff_usage)[[intervention]]
} else{
return_vec[z] <- NA
}
print(paste0(round(z/nrow(x), digits  = 4)*100,"%"))
}
#Progress Bar
return(return_vec)
}
ode_function(x = data.frame(lambda = 1/365*(2),
beta = 5, sigma1 = 0.5, sigma2 = 0.5, sigma3 = 0.25,
r_wt = 1/12, r_r = 1/10,  r_rr = 1/9,  r_rrr = 1/8,
r_t = 1/7, eta_wr = 0.3, eta_rw = 0.04,
eta_rr = 0.01, eta_rrr = 0.01,
c1 = 0.945, c2 = 0.925, c3 = 0.85,
c12 = 0.845, c13 = 0.825, c23 = 0.75,
c123 = 0.7, rho = 0.05, base_tax = 0.5),
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
# Parameters for the eFAST ------------------------------------------------
factors <- c("lambda", "beta", "sigma1", "sigma2", "sigma3", "r_wt", "r_r", "r_rr", "r_rrr", "r_t",
"eta_wr", "eta_rw", "eta_rr", "eta_rrr", "c1", "c2", "c3", "c12", "c13", "c23",
"c123", "rho", "base_tax")
parm_list <- list(list(min=1/3650*(2), max=1/36.5*(2)),
list(min=0.0001, max=5), #beta
list(min=0, max= 1), #sigma1
list(min=0, max = 1), #sigma2
list(min=0, max = 1), #sigma3
list(min=0.0001, max=0.5), #r_wt
list(min=0.0001, max=0.5), #r_r
list(min=0.0001, max = 0.5), #r_rr
list(min=0.0001, max=0.5), #r_rrr
list(min=0.0001, max=0.5), #r_t
list(min=0.0001, max=1), #eta_wr
list(min=0.0001, max=1), #eta_rw
list(min=0.0001, max=1), #eta_rr
list(min=0.0001, max=1), #eta_rrr
list(min=0.5, max=1), #c1
list(min=0.5, max=1), #c2
list(min=0.5, max=1), #c3
list(min=0.5, max=1), #c12
list(min=0.5, max=1), #c13
list(min=0.5, max=1), #c23
list(min=0.5, max=1), #c123
list(min=0.0001, max=1), #rho
list(min=0.0001, max=1))
init <- c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0)
start_time <- Sys.time()
# Single ------------------------------------------------------------------
testres_single <- fast99(model = ode_function, factors = factors, n = 200,
q.arg = parm_list, #base_tax
init = init,
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
ode_function <- function(x, init, parms_base, outcome, intervention, integral,
ode_wrapper, approx_sigma, multi_int_fun, usage_fun) {
return_vec <- c()
for(z in 1:nrow(x)) {
#Create the Parameters
parms = c(lambda = x[z,1],
beta = x[z,2], sigma1 = x[z,3], sigma2 = x[z,4], sigma3 = x[z,5],
r_wt = x[z,6], r_r = x[z,7],  r_rr = x[z,8],  r_rrr = x[z,9],
r_t = x[z,10], eta_wr = x[z,11], eta_rw = x[z,12],
eta_rr = x[z,13], eta_rrr = x[z,14],
c1 = x[z,15], c2 = x[z,16], c3 = x[z,17],
c12 = x[z,18], c13 = x[z,19], c23 = x[z,20],
c123 = x[z,21], base_tax = x[z,23],rho = x[z,22],
t_n = 3000, time_between = Inf, int_round = 1)
#need to rearrange the parameters here - especially sigma
if(parms["sigma1"] + parms["sigma2"] + parms["sigma3"] > 1) {
parms[c("sigma1", "sigma2", "sigma3")] <- as.list(unlist(parms[c("sigma1", "sigma2", "sigma3")])/
(sum(unlist(parms[c("sigma1", "sigma2", "sigma3")])) + runif(1, 0, 1)))
}
print(as.numeric(parms[c("sigma1", "sigma2", "sigma3")]))
parms <- as.list(parms)
parms = append(parms, parms_base["PED"])
parms = append(parms, parms_base["eff_tax"])
#Run Baseline
run_base <- ode_wrapper(y = init, func = amr, times = seq(0, 10000), parms = parms, approx_sigma)[[1]]
run_base_agg <- agg_func(run_base)
values <- tail(run_base_agg, 1)
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
tail_agg <<- tail(run_base_agg, 1)
print(round(tail_agg, digits = 3))
print(round(tail_agg[[2]], digits = 4) != 1)
if(round(tail_agg[[2]], digits = 4) != 1) {
#Identifying the order of the resistances
res_order_vec <- c(names(values[4:6])[which.max(values[4:6])],
names(values[4:6])[setdiff(1:3, c(which.min(values[4:6]), which.max(values[4:6])))],
names(values[4:6])[which.min(values[4:6])])
#Storing baseline info for the integrals
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Single Taxation
parms[["eff_tax"]][as.numeric(substr(res_order_vec[2], 2, 2)), c(1:6)] <- parms[["base_tax"]]
parms[["int_round"]] <- 1
out_run_single <- ode_wrapper(y = init, func = amr, times = seq(0, 10000), parms = parms, approx_sigma)
out_single <- out_run_single[[1]]; parms_single <- out_run_single[[2]]
#Differential Taxation
diff <- multi_int_fun(6, 365*3, parms, init, amr, agg_func, ode_wrapper, approx_sigma)
out_diff <- diff[[1]]
parms_diff <- diff[[2]]
#Integrals
integral_single <- integral(out_single, 3000, 0.5)
integral_diff <- integral(out_diff, 3000, 0.5)
reduc_usage_vec_single <- sum(usage_fun(parms_single)[,6])
reduc_usage_vec_diff <- sum(usage_fun(parms_diff)[,6])
#Store Computation Vectors
single_usage <- list((integral_single[1] - base_tot_inf)/reduc_usage_vec_single,
(base_int_res - integral_single[2])/reduc_usage_vec_single,
integral_single[3],
integral_single[4])[[outcome]]
diff_usage <- list((integral_diff[1] - base_tot_inf)/reduc_usage_vec_diff,
(base_int_res - integral_diff[2])/reduc_usage_vec_diff,
integral_diff[3],
integral_diff[4])[[outcome]]
return_vec[z] <- list(single_usage, diff_usage)[[intervention]]
} else{
return_vec[z] <- NA
}
print(paste0(round(z/nrow(x), digits  = 4)*100,"%"))
}
#Progress Bar
return(return_vec)
}
ode_function(x = data.frame(lambda = 1/365*(2),
beta = 5, sigma1 = 0.5, sigma2 = 0.5, sigma3 = 0.25,
r_wt = 1/12, r_r = 1/10,  r_rr = 1/9,  r_rrr = 1/8,
r_t = 1/7, eta_wr = 0.3, eta_rw = 0.04,
eta_rr = 0.01, eta_rrr = 0.01,
c1 = 0.945, c2 = 0.925, c3 = 0.85,
c12 = 0.845, c13 = 0.825, c23 = 0.75,
c123 = 0.7, rho = 0.05, base_tax = 0.5),
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
# Parameters for the eFAST ------------------------------------------------
factors <- c("lambda", "beta", "sigma1", "sigma2", "sigma3", "r_wt", "r_r", "r_rr", "r_rrr", "r_t",
"eta_wr", "eta_rw", "eta_rr", "eta_rrr", "c1", "c2", "c3", "c12", "c13", "c23",
"c123", "rho", "base_tax")
parm_list <- list(list(min=1/3650*(2), max=1/36.5*(2)),
list(min=0.0001, max=5), #beta
list(min=0, max= 1), #sigma1
list(min=0, max = 1), #sigma2
list(min=0, max = 1), #sigma3
list(min=0.0001, max=0.5), #r_wt
list(min=0.0001, max=0.5), #r_r
list(min=0.0001, max = 0.5), #r_rr
list(min=0.0001, max=0.5), #r_rrr
list(min=0.0001, max=0.5), #r_t
list(min=0.0001, max=1), #eta_wr
list(min=0.0001, max=1), #eta_rw
list(min=0.0001, max=1), #eta_rr
list(min=0.0001, max=1), #eta_rrr
list(min=0.5, max=1), #c1
list(min=0.5, max=1), #c2
list(min=0.5, max=1), #c3
list(min=0.5, max=1), #c12
list(min=0.5, max=1), #c13
list(min=0.5, max=1), #c23
list(min=0.5, max=1), #c123
list(min=0.0001, max=1), #rho
list(min=0.0001, max=1))
init <- c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0)
start_time <- Sys.time()
# Single ------------------------------------------------------------------
testres_single <- fast99(model = ode_function, factors = factors, n = 200,
q.arg = parm_list, #base_tax
init = init,
parms_base = parms_base,
intervention = 1,
outcome = 1,
integral = integral,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
multi_int_fun = multi_int_fun,
usage_fun = usage_fun)
