thresholds <- unlist(out[parms[["t_n"]]-1, 11:13]*thresh)
if(i == 1) {
print(thresholds)
}
under_thresh <- sweep(out[out[,1] > parms[["t_n"]],][,11:13], 2, thresholds)
#Calculate the number of days you are under said threshold
under_50 <- c(nrow(under_thresh[under_thresh$aggR1 < 0,]),
nrow(under_thresh[under_thresh$aggR2 < 0,]),
nrow(under_thresh[under_thresh$aggR3 < 0,]))
#Find the Sum and make each value proportionate to one another
prop_vec <- under_50 / sum(under_50)
prop_vec <- prop_vec[prop_vec != 0]
#Store Computation Vectors
store_vec_inf[i] <- (out_vec[1] - base_tot_inf)/reduc_usage_vec
store_vec_res[i] <- (base_int_res - out_vec[2])/reduc_usage_vec
store_vec_shan[i] <- -sum(sapply(1:length(prop_vec), function(x) prop_vec[x]*log(prop_vec[x])))
}
output <- c(store_vec_inf, store_vec_res, store_vec_shan, parms_base[c(1:20)] )
names(output) <- c("flat_inf", "single1_inf", "single2_inf", "single3_inf", "diff1_inf", "diff2_inf", "diff3_inf", "diff4_inf", "diff5_inf", "diff6_inf",
"flat_res", "single1_res", "single2_res", "single3_res", "diff1_res", "diff2_res", "diff3_res", "diff4_res", "diff5_res", "diff6_res",
"flat_shan", "single1_shan", "single2_shan", "single3_shan", "diff1_shan", "diff2_shan", "diff3_shan", "diff4_shan", "diff5_shan", "diff6_shan",
names(parms_base[c(1:20)]))
return(output)
}
mono_func(500,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75)
mono_func <- function(n, parms_frame, init, amr_ode, usage_fun, multi_int_fun, low_parm, high_parm, agg_func, thresh) {
parms_base = parms_frame[n,]
#Run Baseline
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
if(values[4] == 0 & values[5] == 0 & values[6] == 0) {
while(values[4] == 0 & values[5] == 0 & values[6] == 0) {
parms_base[c(1:20)] <- runif(20,low_parm, high_parm)
parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")] <- sort(as.numeric(parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")]), decreasing = F)
parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")] <-
sort(as.numeric(parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")]), decreasing = T)
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
}
}
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Need to calculate a different baseline for each scenario for antibiotic usage
store_vec_res <- c()
store_vec_inf <- c()
store_vec_shan <- c()
for(i in 1:10){
parms = parms_base
if(i == 1) {
parms[grep("eff_tax", names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 2 & i <= 4) {
parms[grep(paste0("eff_tax", i-1), names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 5 & i <= 10) {
diff <- multi_int_fun(i-4, 365*3, parms, init, amr_ode, agg_func)
out <- diff[[1]]
parms <- diff[[2]]
}
data_temp <- out[out[,1] > parms[["t_n"]],]
data_temp_agg <- agg_func(data_temp)
out_vec <- signif(c(sum(data_temp[3:10]),
sum(rowMeans(data_temp_agg[4:6]))),5)
reduc_usage_vec <- sum(usage_fun(parms, out)[,6])
#Aggregation
out$aggR1 <- out$R1 + out$R12 + out$R13 + out$R123
out$aggR2 <- out$R2 + out$R12 + out$R23 + out$R123
out$aggR3 <- out$R3 + out$R13 + out$R23 + out$R123
#Determine the X% Thresholds that you want to be under
thresholds <- unlist(out[parms[["t_n"]]-1, 11:13]*thresh)
if(i == 1) {
print(thresholds)
}
if(i == 1) {
print(out)
}
under_thresh <- sweep(out[out[,1] > parms[["t_n"]],][,11:13], 2, thresholds)
#Calculate the number of days you are under said threshold
under_50 <- c(nrow(under_thresh[under_thresh$aggR1 < 0,]),
nrow(under_thresh[under_thresh$aggR2 < 0,]),
nrow(under_thresh[under_thresh$aggR3 < 0,]))
#Find the Sum and make each value proportionate to one another
prop_vec <- under_50 / sum(under_50)
prop_vec <- prop_vec[prop_vec != 0]
#Store Computation Vectors
store_vec_inf[i] <- (out_vec[1] - base_tot_inf)/reduc_usage_vec
store_vec_res[i] <- (base_int_res - out_vec[2])/reduc_usage_vec
store_vec_shan[i] <- -sum(sapply(1:length(prop_vec), function(x) prop_vec[x]*log(prop_vec[x])))
}
output <- c(store_vec_inf, store_vec_res, store_vec_shan, parms_base[c(1:20)] )
names(output) <- c("flat_inf", "single1_inf", "single2_inf", "single3_inf", "diff1_inf", "diff2_inf", "diff3_inf", "diff4_inf", "diff5_inf", "diff6_inf",
"flat_res", "single1_res", "single2_res", "single3_res", "diff1_res", "diff2_res", "diff3_res", "diff4_res", "diff5_res", "diff6_res",
"flat_shan", "single1_shan", "single2_shan", "single3_shan", "diff1_shan", "diff2_shan", "diff3_shan", "diff4_shan", "diff5_shan", "diff6_shan",
names(parms_base[c(1:20)]))
return(output)
}
mono_func(500,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75)
under_thresh <- sweep(out[out[,1] > parms[["t_n"]],][,11:13], 2, thresholds)
mono_func <- function(n, parms_frame, init, amr_ode, usage_fun, multi_int_fun, low_parm, high_parm, agg_func, thresh) {
parms_base = parms_frame[n,]
#Run Baseline
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
if(values[4] == 0 & values[5] == 0 & values[6] == 0) {
while(values[4] == 0 & values[5] == 0 & values[6] == 0) {
parms_base[c(1:20)] <- runif(20,low_parm, high_parm)
parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")] <- sort(as.numeric(parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")]), decreasing = F)
parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")] <-
sort(as.numeric(parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")]), decreasing = T)
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
}
}
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Need to calculate a different baseline for each scenario for antibiotic usage
store_vec_res <- c()
store_vec_inf <- c()
store_vec_shan <- c()
for(i in 1:10){
parms = parms_base
if(i == 1) {
parms[grep("eff_tax", names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 2 & i <= 4) {
parms[grep(paste0("eff_tax", i-1), names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 5 & i <= 10) {
diff <- multi_int_fun(i-4, 365*3, parms, init, amr_ode, agg_func)
out <- diff[[1]]
parms <- diff[[2]]
}
data_temp <- out[out[,1] > parms[["t_n"]],]
data_temp_agg <- agg_func(data_temp)
out_vec <- signif(c(sum(data_temp[3:10]),
sum(rowMeans(data_temp_agg[4:6]))),5)
reduc_usage_vec <- sum(usage_fun(parms, out)[,6])
#Aggregation
out$aggR1 <- out$R1 + out$R12 + out$R13 + out$R123
out$aggR2 <- out$R2 + out$R12 + out$R23 + out$R123
out$aggR3 <- out$R3 + out$R13 + out$R23 + out$R123
#Determine the X% Thresholds that you want to be under
thresholds <- unlist(out[parms[["t_n"]]-1, 11:13]*thresh)
if(i == 1) {
print(thresholds)
}
if(i == 1) {
print(out[out[,1] > parms[["t_n"]],])
}
under_thresh <- sweep(out[out[,1] > parms[["t_n"]],][,11:13], 2, thresholds)
#Calculate the number of days you are under said threshold
under_50 <- c(nrow(under_thresh[under_thresh$aggR1 < 0,]),
nrow(under_thresh[under_thresh$aggR2 < 0,]),
nrow(under_thresh[under_thresh$aggR3 < 0,]))
#Find the Sum and make each value proportionate to one another
prop_vec <- under_50 / sum(under_50)
prop_vec <- prop_vec[prop_vec != 0]
#Store Computation Vectors
store_vec_inf[i] <- (out_vec[1] - base_tot_inf)/reduc_usage_vec
store_vec_res[i] <- (base_int_res - out_vec[2])/reduc_usage_vec
store_vec_shan[i] <- -sum(sapply(1:length(prop_vec), function(x) prop_vec[x]*log(prop_vec[x])))
}
output <- c(store_vec_inf, store_vec_res, store_vec_shan, parms_base[c(1:20)] )
names(output) <- c("flat_inf", "single1_inf", "single2_inf", "single3_inf", "diff1_inf", "diff2_inf", "diff3_inf", "diff4_inf", "diff5_inf", "diff6_inf",
"flat_res", "single1_res", "single2_res", "single3_res", "diff1_res", "diff2_res", "diff3_res", "diff4_res", "diff5_res", "diff6_res",
"flat_shan", "single1_shan", "single2_shan", "single3_shan", "diff1_shan", "diff2_shan", "diff3_shan", "diff4_shan", "diff5_shan", "diff6_shan",
names(parms_base[c(1:20)]))
return(output)
}
mono_func(500,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75)
mono_func <- function(n, parms_frame, init, amr_ode, usage_fun, multi_int_fun, low_parm, high_parm, agg_func, thresh) {
parms_base = parms_frame[n,]
#Run Baseline
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
if(values[4] == 0 & values[5] == 0 & values[6] == 0) {
while(values[4] == 0 & values[5] == 0 & values[6] == 0) {
parms_base[c(1:20)] <- runif(20, low_parm, high_parm)
parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")] <- sort(as.numeric(parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")]), decreasing = F)
parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")] <-
sort(as.numeric(parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")]), decreasing = T)
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
}
}
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Need to calculate a different baseline for each scenario for antibiotic usage
store_vec_res <- c()
store_vec_inf <- c()
store_vec_shan <- c()
for(i in 1:10){
parms = parms_base
if(i == 1) {
parms[grep("eff_tax", names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 2 & i <= 4) {
parms[grep(paste0("eff_tax", i-1), names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 5 & i <= 10) {
diff <- multi_int_fun(i-4, 365*3, parms, init, amr_ode, agg_func)
out <- diff[[1]]
parms <- diff[[2]]
}
data_temp <- out[out[,1] > parms[["t_n"]],]
data_temp_agg <- agg_func(data_temp)
out_vec <- signif(c(sum(data_temp[3:10]),
sum(rowMeans(data_temp_agg[4:6]))),5)
reduc_usage_vec <- sum(usage_fun(parms, out)[,6])
#Aggregation
out$aggR1 <- out$R1 + out$R12 + out$R13 + out$R123
out$aggR2 <- out$R2 + out$R12 + out$R23 + out$R123
out$aggR3 <- out$R3 + out$R13 + out$R23 + out$R123
#Determine the X% Thresholds that you want to be under
thresholds <- unlist(out[parms[["t_n"]]-1, 11:13]*thresh)
if(i == 1) {
print(thresholds)
}
if(i == 1) {
print(out[out[,1] > parms[["t_n"]],])
}
under_thresh <- sweep(out[out[,1] > parms[["t_n"]],][,11:13], 2, thresholds)
#Calculate the number of days you are under said threshold
under_50 <- c(nrow(under_thresh[under_thresh$aggR1 < 0,]),
nrow(under_thresh[under_thresh$aggR2 < 0,]),
nrow(under_thresh[under_thresh$aggR3 < 0,]))
#Find the Sum and make each value proportionate to one another
prop_vec <- under_50 / sum(under_50)
prop_vec <- prop_vec[prop_vec != 0]
#Store Computation Vectors
store_vec_inf[i] <- (out_vec[1] - base_tot_inf)/reduc_usage_vec
store_vec_res[i] <- (base_int_res - out_vec[2])/reduc_usage_vec
store_vec_shan[i] <- -sum(sapply(1:length(prop_vec), function(x) prop_vec[x]*log(prop_vec[x])))
}
output <- c(store_vec_inf, store_vec_res, store_vec_shan, parms_base[c(1:20)])
names(output) <- c("flat_inf", "single1_inf", "single2_inf", "single3_inf", "diff1_inf", "diff2_inf", "diff3_inf", "diff4_inf", "diff5_inf", "diff6_inf",
"flat_res", "single1_res", "single2_res", "single3_res", "diff1_res", "diff2_res", "diff3_res", "diff4_res", "diff5_res", "diff6_res",
"flat_shan", "single1_shan", "single2_shan", "single3_shan", "diff1_shan", "diff2_shan", "diff3_shan", "diff4_shan", "diff5_shan", "diff6_shan",
names(parms_base[c(1:20)]))
return(output)
}
mono_func(500,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75)
mono_func <- function(n, parms_frame, init, amr_ode, usage_fun, multi_int_fun, low_parm, high_parm, agg_func, thresh) {
parms_base = parms_frame[n,]
#Run Baseline
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
if(values[4] == 0 & values[5] == 0 & values[6] == 0) {
while(values[4] == 0 & values[5] == 0 & values[6] == 0) {
parms_base[c(1:20)] <- runif(20, low_parm, high_parm)
parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")] <- sort(as.numeric(parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")]), decreasing = F)
parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")] <-
sort(as.numeric(parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")]), decreasing = T)
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
}
}
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Need to calculate a different baseline for each scenario for antibiotic usage
store_vec_res <- c()
store_vec_inf <- c()
store_vec_shan <- c()
for(i in 1:10){
parms = parms_base
if(i == 1) {
parms[grep("eff_tax", names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 2 & i <= 4) {
parms[grep(paste0("eff_tax", i-1), names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 5 & i <= 10) {
diff <- multi_int_fun(i-4, 365*3, parms, init, amr_ode, agg_func)
out <- diff[[1]]
parms <- diff[[2]]
}
data_temp <- out[out[,1] > parms[["t_n"]],]
data_temp_agg <- agg_func(data_temp)
out_vec <- signif(c(sum(data_temp[3:10]),
sum(rowMeans(data_temp_agg[4:6]))),5)
reduc_usage_vec <- sum(usage_fun(parms, out)[,6])
#Aggregation
out$aggR1 <- out$R1 + out$R12 + out$R13 + out$R123
out$aggR2 <- out$R2 + out$R12 + out$R23 + out$R123
out$aggR3 <- out$R3 + out$R13 + out$R23 + out$R123
#Determine the X% Thresholds that you want to be under
thresholds <- unlist(out[parms[["t_n"]]-1, 11:13]*thresh)
if(i == 1) {
print(thresholds)
}
if(i == 1) {
print(out[out[,1] > parms[["t_n"]],][,11:13])
}
under_thresh <- sweep(out[out[,1] > parms[["t_n"]],][,11:13], 2, thresholds)
#Calculate the number of days you are under said threshold
under_50 <- c(nrow(under_thresh[under_thresh$aggR1 < 0,]),
nrow(under_thresh[under_thresh$aggR2 < 0,]),
nrow(under_thresh[under_thresh$aggR3 < 0,]))
#Find the Sum and make each value proportionate to one another
prop_vec <- under_50 / sum(under_50)
prop_vec <- prop_vec[prop_vec != 0]
#Store Computation Vectors
store_vec_inf[i] <- (out_vec[1] - base_tot_inf)/reduc_usage_vec
store_vec_res[i] <- (base_int_res - out_vec[2])/reduc_usage_vec
store_vec_shan[i] <- -sum(sapply(1:length(prop_vec), function(x) prop_vec[x]*log(prop_vec[x])))
}
output <- c(store_vec_inf, store_vec_res, store_vec_shan, parms_base[c(1:20)])
names(output) <- c("flat_inf", "single1_inf", "single2_inf", "single3_inf", "diff1_inf", "diff2_inf", "diff3_inf", "diff4_inf", "diff5_inf", "diff6_inf",
"flat_res", "single1_res", "single2_res", "single3_res", "diff1_res", "diff2_res", "diff3_res", "diff4_res", "diff5_res", "diff6_res",
"flat_shan", "single1_shan", "single2_shan", "single3_shan", "diff1_shan", "diff2_shan", "diff3_shan", "diff4_shan", "diff5_shan", "diff6_shan",
names(parms_base[c(1:20)]))
return(output)
}
mono_func(500,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75)
mono_func <- function(n, parms_frame, init, amr_ode, usage_fun, multi_int_fun, low_parm, high_parm, agg_func, thresh) {
parms_base = parms_frame[n,]
#Run Baseline
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
if(values[4] == 0 & values[5] == 0 & values[6] == 0) {
while(values[4] == 0 & values[5] == 0 & values[6] == 0) {
parms_base[c(1:20)] <- runif(20, low_parm, high_parm)
parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")] <- sort(as.numeric(parms_base[c("r_wt", "r_r", "r_rr", "r_rrr", "r_t")]), decreasing = F)
parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")] <-
sort(as.numeric(parms_base[c("c1", "c2", "c3", "c12", "c13", "c23", "c123")]), decreasing = T)
run_base <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms_base, hmax = 1)))
run_base_agg <- agg_func(run_base)
values <- tail(run_base, 1)
}
}
run <- run_base[run_base[,1] > parms[["t_n"]],]
run_base_agg <- run_base_agg[run_base_agg[,1] > parms[["t_n"]],]
base_tot_inf <- signif(sum(run[3:10]), 5)
base_int_res <- signif(sum(rowMeans(run_base_agg[4:6]), 5))
#Need to calculate a different baseline for each scenario for antibiotic usage
store_vec_res <- c()
store_vec_inf <- c()
store_vec_shan <- c()
for(i in 1:10){
parms = parms_base
if(i == 1) {
parms[grep("eff_tax", names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 2 & i <= 4) {
parms[grep(paste0("eff_tax", i-1), names(parms), value =T)]  <- parms[["base_tax"]]
out <- remNA_func(data.frame(ode(y = init, func = amr_ode, times = seq(0, 10000), parms = parms, hmax = 1)))
}
if(i >= 5 & i <= 10) {
diff <- multi_int_fun(i-4, 365*3, parms, init, amr_ode, agg_func)
out <- diff[[1]]
parms <- diff[[2]]
}
data_temp <- out[out[,1] > parms[["t_n"]],]
data_temp_agg <- agg_func(data_temp)
out_vec <- signif(c(sum(data_temp[3:10]),
sum(rowMeans(data_temp_agg[4:6]))),5)
reduc_usage_vec <- sum(usage_fun(parms, out)[,6])
#Aggregation
out$aggR1 <- out$R1 + out$R12 + out$R13 + out$R123
out$aggR2 <- out$R2 + out$R12 + out$R23 + out$R123
out$aggR3 <- out$R3 + out$R13 + out$R23 + out$R123
#Determine the X% Thresholds that you want to be under
thresholds <- unlist(out[parms[["t_n"]]-1, 11:13]*thresh)
if(i == 1) {
print(thresholds)
}
if(i == 1) {
print(out[out[,1] > parms[["t_n"]],][,11:13])
print(parms)
}
under_thresh <- sweep(out[out[,1] > parms[["t_n"]],][,11:13], 2, thresholds)
#Calculate the number of days you are under said threshold
under_50 <- c(nrow(under_thresh[under_thresh$aggR1 < 0,]),
nrow(under_thresh[under_thresh$aggR2 < 0,]),
nrow(under_thresh[under_thresh$aggR3 < 0,]))
#Find the Sum and make each value proportionate to one another
prop_vec <- under_50 / sum(under_50)
prop_vec <- prop_vec[prop_vec != 0]
#Store Computation Vectors
store_vec_inf[i] <- (out_vec[1] - base_tot_inf)/reduc_usage_vec
store_vec_res[i] <- (base_int_res - out_vec[2])/reduc_usage_vec
store_vec_shan[i] <- -sum(sapply(1:length(prop_vec), function(x) prop_vec[x]*log(prop_vec[x])))
}
output <- c(store_vec_inf, store_vec_res, store_vec_shan, parms_base[c(1:20)])
names(output) <- c("flat_inf", "single1_inf", "single2_inf", "single3_inf", "diff1_inf", "diff2_inf", "diff3_inf", "diff4_inf", "diff5_inf", "diff6_inf",
"flat_res", "single1_res", "single2_res", "single3_res", "diff1_res", "diff2_res", "diff3_res", "diff4_res", "diff5_res", "diff6_res",
"flat_shan", "single1_shan", "single2_shan", "single3_shan", "diff1_shan", "diff2_shan", "diff3_shan", "diff4_shan", "diff5_shan", "diff6_shan",
names(parms_base[c(1:20)]))
return(output)
}
mono_func(500,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75)
mono_func(600,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75)
test <- mclapply(1:10,
FUN = mono_func,
parms_frame = parm_data_comb,
init = c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0),
amr_ode = amr,
usage_fun = usage_fun,
multi_int_fun = multi_int_fun,
low_parm = low_parm,
high_parm = high_parm,
agg_func = agg_func,
thresh = 0.75,
mc.cores = 10)
test
setwd("/Users/amorgan/Documents/PostDoc/Diff_Tax_Analysis/Theoretical_Analysis/Formalised_Anal/Model_Output/")
setwd("/Users/amorgan/Documents/PostDoc/Diff_Tax_Analysis/Theoretical_Analysis/Formalised_Analysis/Model_Output/")
