prop_win_shan$Interventions <- factor(prop_win_shan$Interventions, levels = c(prop_win_shan$Interventions))
# Average Number of Available Antibiotics ---------------------------------
win_avganti <- round((win_import[,31:40]), 5)
win_avganti[is.na(win_avganti)] <- 0
win_avganti <- win_avganti[rowSums(win_avganti[, -1]) > 0, ]
win_avganti_trans <- t(apply(win_avganti, 1, function(x) {
val = max(x)
x[is.na(x)] <- 0
x[x != val] <- 0
x[x == val] <- 1
return(x)}
))
prop_win_avganti <- data.frame("Average_Anti" = colSums(win_avganti_trans)/nrow(win_avganti_trans),
"Interventions" = as.factor(c("Flat Tax", "Single Tax (HR)", "Single Tax (MR)",
"Single Tax (LR)",
"Diff Tax (1 Round)", "Diff Tax (2 Round)",
"Diff Tax (3 Round)", "Diff Tax (4 Round)",
"Diff Tax (5 Round)", "Diff Tax (6 Round)")))
prop_win_avganti$Interventions <- factor(prop_win_avganti$Interventions, levels = c(prop_win_avganti$Interventions))
# Combining All Together --------------------------------------------------
combdata <- prop_win_res; combdata$Infections <- prop_win_inf$Infections; combdata$Shannon <- prop_win_shan$Shannon_Index
combdata$Average_Anti <- prop_win_avganti$Average_Anti
melt_combdata <- melt(combdata, id.vars = "Interventions", measure.vars = c("Resistance", "Infections", "Shannon", "Average_Anti"))
melt_combdata$Interventions <- factor(melt_combdata$Interventions, levels = c(prop_win_res$Interventions))
# Plotting win Probabilities ----------------------------------------------
p_inf <- ggplot(prop_win_inf, aes(y = Infections, x = as.factor(Interventions))) + geom_bar(stat="identity")  + theme_bw() +
scale_x_discrete(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01)) +
labs(y ="Probability of Optimality (Preventing Infections)", x = "", fill = "") +
theme(legend.position= "bottom", legend.text=element_text(size=12), legend.title =element_text(size=12), axis.text=element_text(size=12),
axis.title.y=element_text(size=12), axis.title.x= element_text(size=12), plot.margin = unit(c(0.35,1,0.35,1), "cm"),
legend.spacing.x = unit(0.3, 'cm'), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
p_res <- ggplot(prop_win_res, aes(y = Resistance, x = as.factor(Interventions))) + geom_bar(stat="identity") + theme_bw() +
scale_x_discrete(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01)) +
labs(y ="Probability of Optimality (Resistance Decrease)", x = "", fill = "") +
theme(legend.position= "bottom", legend.text=element_text(size=12), legend.title =element_text(size=12), axis.text=element_text(size=12),
axis.title.y=element_text(size=12), axis.title.x= element_text(size=12), plot.margin = unit(c(0.35,1,0.35,1), "cm"),
legend.spacing.x = unit(0.3, 'cm'), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
p_shan <- ggplot(prop_win_shan, aes(y = Shannon_Index, x = as.factor(Interventions))) + geom_bar(stat="identity") + theme_bw() +
scale_x_discrete(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01)) +
labs(y ="Probability of Optimality (Highest SI)", x = "", fill = "") +
theme(legend.position= "bottom", legend.text=element_text(size=12), legend.title =element_text(size=12), axis.text=element_text(size=12),
axis.title.y=element_text(size=12), axis.title.x= element_text(size=12), plot.margin = unit(c(0.35,1,0.35,1), "cm"),
legend.spacing.x = unit(0.3, 'cm'), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
p_avg_anti <- ggplot(prop_win_avganti, aes(y = Average_Anti, x = as.factor(Interventions))) + geom_bar(stat="identity") + theme_bw() +
scale_x_discrete(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01)) +
labs(y ="Probability of Optimality (Highest SI)", x = "", fill = "") +
theme(legend.position= "bottom", legend.text=element_text(size=12), legend.title =element_text(size=12), axis.text=element_text(size=12),
axis.title.y=element_text(size=12), axis.title.x= element_text(size=12), plot.margin = unit(c(0.35,1,0.35,1), "cm"),
legend.spacing.x = unit(0.3, 'cm'), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
ggarrange(p_inf, p_res, p_shan, ncol = 1, nrow = 4)
#Combination Plot
p_comb <- ggplot(melt_combdata, aes(y = value, x = as.factor(Interventions), fill = variable)) +
geom_bar(stat="identity", position = position_dodge())  + theme_bw() +
scale_x_discrete(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01)) +
labs(y ="Probability of Intervention Winning", x = "", fill = "") +
theme(legend.position= "bottom", legend.text=element_text(size=12), legend.title =element_text(size=12), axis.text=element_text(size=12),
axis.title.y=element_text(size=12), axis.title.x= element_text(size=12), plot.margin = unit(c(0.35,1,0.35,1), "cm"),
legend.spacing.x = unit(0.3, 'cm'), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
scale_fill_manual(values = c("red", "blue", "orange", "darkgreen"),labels = c("Resistance", "Infections","Shannons Index", "Average Antibiotics"))
# Proportion of Wins HeatMap ----------------------------------------------
melt_combdata$value <- round(melt_combdata$value, digits = 3)
ggplot(melt_combdata, aes(Interventions, variable)) + theme_bw() +
geom_tile(aes(fill = value)) +
facet_grid(variable ~ ., scales = "free_y") +
geom_text(aes(label=value), color = "black") +
scale_fill_distiller(palette ="Blues", direction = 1) +
scale_x_discrete(name = "", expand = c(0, 0))  +
scale_y_discrete(name = "Outcome Measure", expand = c(0, 0)) +
guides(fill = guide_colorbar(title = "Probabilty that \nIntervention Wins",
label.position = "bottom",
title.position = "left", title.vjust = 1,
# draw border around the legend
frame.colour = "black",
barwidth = 15,
barheight = 1)) +
theme(strip.background = element_blank(), axis.text=element_text(size=11),
strip.text = element_blank(), legend.position="bottom",
axis.text.x = element_text(angle = 45, hjust=1))
# Isolated Sensitivity Analysis -------------------------------------------
#For Infections and Resistance
combdata_infres <- prop_win_res; combdata_infres$Infections <- prop_win_inf$Infections
melt_combdata_infres <- melt(combdata, id.vars = "Interventions", measure.vars = c("Resistance", "Infections"))
melt_combdata_infres$Interventions <- factor(melt_combdata_infres$Interventions, levels = c(prop_win_res$Interventions))
melt_combdata_infres$value <- round(melt_combdata_infres$value, digits = 3)
ggplot(melt_combdata_infres, aes(Interventions, variable)) + theme_bw() +
geom_tile(aes(fill = value)) +
facet_grid(variable ~ ., scales = "free_y") +
geom_text(aes(label=value), color = "black") +
scale_fill_distiller(palette ="Blues", direction = 1) +
scale_x_discrete(name = "", expand = c(0, 0))  +
scale_y_discrete(name = "Outcome Measure", expand = c(0, 0)) +
guides(fill = guide_colorbar(title = "Probabilty that \nIntervention Wins",
label.position = "bottom",
title.position = "left", title.vjust = 1,
# draw border around the legend
frame.colour = "black",
barwidth = 15,
barheight = 1)) +
theme(strip.background = element_blank(), axis.text=element_text(size=11),
strip.text = element_blank(), legend.position="bottom",
axis.text.x = element_text(angle = 45, hjust=1))
#For antibiotic availability related measures
combdata_shanavg <- prop_win_shan
combdata_shanavg$Average_Anti <- prop_win_avganti$Average_Anti
melt_combdata_shanavg<- melt(combdata_shanavg, id.vars = "Interventions", measure.vars = c("Shannon_Index", "Average_Anti"))
melt_combdata_shanavg$Interventions <- factor(melt_combdata_shanavg$Interventions, levels = c(prop_win_res$Interventions))
melt_combdata_shanavg$value <- round(melt_combdata_shanavg$value, digits = 3)
ggplot(melt_combdata_shanavg, aes(Interventions, variable)) + theme_bw() +
geom_tile(aes(fill = value)) +
facet_grid(variable ~ ., scales = "free_y") +
geom_text(aes(label=value), color = "black") +
scale_fill_distiller(palette ="Blues", direction = 1) +
scale_x_discrete(name = "", expand = c(0, 0))  +
scale_y_discrete(name = "Outcome Measure", expand = c(0, 0)) +
guides(fill = guide_colorbar(title = "Probabilty that \nIntervention Wins",
label.position = "bottom",
title.position = "left", title.vjust = 1,
# draw border around the legend
frame.colour = "black",
barwidth = 15,
barheight = 1)) +
theme(strip.background = element_blank(), axis.text=element_text(size=11),
strip.text = element_blank(), legend.position="bottom",
axis.text.x = element_text(angle = 45, hjust=1))
library("deSolve"); library("ggplot2"); library("plotly"); library("reshape2")
library("bayestestR")
rm(list=ls())
# Model -------------------------------------------------------------------
amr <- function(t, y, parms, sigma_use1, sigma_use2, sigma_use3) {
with(as.list(c(y, parms)), {
#Specify the time-varying functions
sigma_use1 <- sigma_func1(t)
sigma_use2 <- sigma_func2(t)
sigma_use3 <- sigma_func3(t)
#ODES Below
dX = lambda - lambda*X - beta*X*(Wt + R1*c1 + R2*c2 + R3*c3 + R12*c12 + R13*c13 + R23*c23 + R123*c123) +
r_wt*Wt*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + r_r*R1*(1-(sigma_use2 + sigma_use3)) + r_r*R2*(1-(sigma_use1 + sigma_use3)) + r_r*R3*(1-(sigma_use1 + sigma_use2)) +
r_rr*R12*(1-sigma_use3) + r_rr*R13*(1-sigma_use2) + r_rr*R23*(1-sigma_use1) +
r_rrr*R123 +
r_t*(1-rho)*(Wt*(sigma_use1 + sigma_use2 + sigma_use3) + R1*(sigma_use2 + sigma_use3) +
R2*(sigma_use1 + sigma_use3) + R3*(sigma_use1 + sigma_use2) +
R12*sigma_use3 + R13*sigma_use2 + R23*sigma_use1)
dWt = - lambda*Wt + beta*X*Wt - r_wt*Wt*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) - r_t*Wt*(1-rho)*(sigma_use1 + sigma_use2 + sigma_use3) +
eta_rw*(R1 + R2 + R3 + R12 + R13 + R23 + R123)*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) -
eta_wr*Wt*rho*(sigma_use1 + sigma_use2 + sigma_use3)
dR1 = - lambda*R1 + beta*X*R1*c1 - r_t*(1-rho)*(sigma_use2 + sigma_use3)*R1 - r_r*(1-(sigma_use2 + sigma_use3))*R1 - eta_rr*R1*rho*sigma_use2 -
eta_rr*R1*rho*sigma_use3 - eta_rw*R1*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use1
dR2 = - lambda*R2 + beta*X*R2*c2 - r_t*(1-rho)*(sigma_use1 + sigma_use3)*R2 - r_r*(1-(sigma_use1 + sigma_use3))*R2 - eta_rr*R2*rho*sigma_use1 -
eta_rr*R2*rho*sigma_use3 - eta_rw*R2*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use2
dR3 = - lambda*R3 + beta*X*R3*c3 - r_t*(1-rho)*(sigma_use1 + sigma_use2)*R3 - r_r*(1-(sigma_use1 + sigma_use2))*R3 - eta_rr*R3*rho*sigma_use1 -
eta_rr*R3*rho*sigma_use2 - eta_rw*R3*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use3
dR12 = - lambda*R12 + beta*X*R12*c12 - r_t*(1-rho)*sigma_use3*R12 - r_rr*(1-sigma_use3)*R12 - eta_rrr*R12*rho*sigma_use3 -
eta_rw*R12*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R1*rho*sigma_use2 + eta_rr*R2*rho*sigma_use1
dR13 = - lambda*R13 + beta*X*R13*c13 - r_t*(1-rho)*sigma_use2*R13 - r_rr*(1-sigma_use2)*R13 - eta_rrr*R13*rho*sigma_use2 -
eta_rw*R13*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R1*rho*sigma_use3 + eta_rr*R3*rho*sigma_use1
dR23 = - lambda*R23 + beta*X*R23*c23 - r_t*(1-rho)*sigma_use1*R23 - r_rr*(1-sigma_use1)*R23 - eta_rrr*R23*rho*sigma_use1 -
eta_rw*R23*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R2*rho*sigma_use3 + eta_rr*R3*rho*sigma_use2
dR123 = - lambda*R123 + beta*X*R123*c123 - r_rrr*R123 - eta_rw*R123*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) +
eta_rrr*rho*(sigma_use3*R12 + sigma_use2*R13 + sigma_use1*R23)
return(list(c(dX,dWt,
dR1,dR2,dR3,
dR12,dR13,dR23,
dR123)))
})
}
# Extract Sigmas for the ApproxFun Function -------------------------------
approx_sigma <- function(sigma_mat){
usage = data.frame("time" = seq(0,10000),
"PopUsage1" = c(rep(sigma_mat[1,1], 3000),
rep(sigma_mat[1,2], 365*3), rep(sigma_mat[1,3], 365*3), rep(sigma_mat[1,4], 365*3),
rep(sigma_mat[1,5], 365*3), rep(sigma_mat[1,6], 365*3), rep(sigma_mat[1,7], 10001 - (3000 + (365*3)*5))),
"PopUsage2" = c(rep(sigma_mat[2,1], 3000),
rep(sigma_mat[2,2], 365*3), rep(sigma_mat[2,3], 365*3), rep(sigma_mat[2,4], 365*3),
rep(sigma_mat[2,5], 365*3), rep(sigma_mat[2,6], 365*3), rep(sigma_mat[2,7], 10001 - (3000 + (365*3)*5))),
"PopUsage3" = c(rep(sigma_mat[3,1], 3000),
rep(sigma_mat[3,2], 365*3), rep(sigma_mat[3,3], 365*3), rep(sigma_mat[3,4], 365*3),
rep(sigma_mat[3,5], 365*3), rep(sigma_mat[3,6], 365*3), rep(sigma_mat[3,7], 10001 - (3000 + (365*3)*5))))
return(usage)
}
# ODE Wrapper Function ----------------------------------------------------
ode_wrapper <- function(times, y, parms, func, approx_sigma) {
sigma_mat = matrix(c(rep(parms[["sigma1"]], 7),
rep(parms[["sigma2"]], 7),
rep(parms[["sigma3"]], 7)),
nrow = 3, ncol = 7, byrow = T)
eff_tax <- parms[["eff_tax"]]; PED <- parms[["PED"]]
if(parms[["int_round"]] > 0 ) {
for(i in 1:parms[["int_round"]]) {
stor_sigma <- sigma_mat[,i]
sigma_mat[,(i+1):7] = c(stor_sigma[1]*(1 + ((eff_tax[1,i]*PED[1,1]) + (eff_tax[2,i]*PED[2,1]) + (eff_tax[3,i]*PED[3,1]))),
stor_sigma[2]*(1 + ((eff_tax[1,i]*PED[1,2]) + (eff_tax[2,i]*PED[2,2]) + (eff_tax[3,i]*PED[3,2]))),
stor_sigma[3]*(1 + ((eff_tax[1,i]*PED[1,3]) + (eff_tax[2,i]*PED[2,3]) + (eff_tax[3,i]*PED[3,3]))))
sigma_mat[,(i+1):7][sigma_mat[,(i+1)] < 0.01] <- 0.01
if(colSums(sigma_mat)[i+1] > 1) {
sigma_mat[,(i+1):7] <- sigma_mat[,i+1]/(sum(sigma_mat[,i+1])+0.01)
}
}
}
parms[["sigma_mat"]] <- sigma_mat
sigma_data <- approx_sigma(sigma_mat)
sigma_func1 <<- approxfun(sigma_data[,c(1,2)], rule = 2)
sigma_func2 <<- approxfun(sigma_data[,c(1,3)], rule = 2)
sigma_func3 <<- approxfun(sigma_data[,c(1,4)], rule = 2)
#Run the model
out <- data.frame(ode(y = init, func = func, times = times, parms = parms))
return(list(out, parms))
}
# Function to Aggregate Resistance ----------------------------------------
agg_func <- function(data) {
agg_data <- data.frame("time" = data$time,
"Susc" = data$X,
"WT" = data$Wt,
"R1" = data$R1 + data$R12 + data$R13 + data$R123,
"R2" = data$R2 + data$R12 + data$R23 + data$R123,
"R3" = data$R3 + data$R13 + data$R23 + data$R123)
return(agg_data)
}
# Test Parms --------------------------------------------------------------
init <- c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0)
parms = list(lambda = 1/365*(2), int_round = 1,
beta = 5, sigma1 = 0.25, sigma2 = 0.25, sigma3 = 0.25,
r_wt = 1/12, r_r = 1/10,  r_rr = 1/9,  r_rrr = 1/8,
r_t = 1/7, eta_wr = 0.3, eta_rw = 0.04,
eta_rr = 0.01, eta_rrr = 0.01,
c1 = 0.945, c2 = 0.925, c3 = 0.85,
c12 = 0.845, c13 = 0.825, c23 = 0.75,
c123 = 0.7,
PED = matrix(c(-1, 0.4, 0.4,
0.4, -1, 0.4,
0.4, 0.4, -1), #Be aware of this matrix
nrow = 3, ncol = 3, byrow = T),
eff_tax = matrix(c(0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0),
nrow = 3, ncol = 6, byrow = T),
t_n = 3000, time_between = Inf, rho = 0.05, base_tax = 0.5)
#Compute the distances for all 3 summary statistics - this section involves running the model
computeDistanceABC_ALEX <- function(fitmodel, ode_wrapper, approx_sigma, thetaparm, init.state) {
out <- ode_wrapper(y = init.state, func = fitmodel, times = seq(0, 10000), parms = thetaparm, approx_sigma)[[1]]
end_res <- tail(agg_func(out)[4:6], 1)
return(c(end_res[1] - 0.4,
end_res[2] - 0.25,
end_res[3] - 0.1))
}
computeDistanceABC_ALEX(fitmodel = amr,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
thetaparm = parms,
init.state = init)
library("deSolve"); library("ggplot2"); library("plotly"); library("reshape2")
library("bayestestR")
rm(list=ls())
# Model -------------------------------------------------------------------
amr <- function(t, y, parms, sigma_use1, sigma_use2, sigma_use3) {
with(as.list(c(y, parms)), {
#Specify the time-varying functions
sigma_use1 <- sigma_func1(t)
sigma_use2 <- sigma_func2(t)
sigma_use3 <- sigma_func3(t)
#ODES Below
dX = lambda - lambda*X - beta*X*(Wt + R1*c1 + R2*c2 + R3*c3 + R12*c12 + R13*c13 + R23*c23 + R123*c123) +
r_wt*Wt*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + r_r*R1*(1-(sigma_use2 + sigma_use3)) + r_r*R2*(1-(sigma_use1 + sigma_use3)) + r_r*R3*(1-(sigma_use1 + sigma_use2)) +
r_rr*R12*(1-sigma_use3) + r_rr*R13*(1-sigma_use2) + r_rr*R23*(1-sigma_use1) +
r_rrr*R123 +
r_t*(1-rho)*(Wt*(sigma_use1 + sigma_use2 + sigma_use3) + R1*(sigma_use2 + sigma_use3) +
R2*(sigma_use1 + sigma_use3) + R3*(sigma_use1 + sigma_use2) +
R12*sigma_use3 + R13*sigma_use2 + R23*sigma_use1)
dWt = - lambda*Wt + beta*X*Wt - r_wt*Wt*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) - r_t*Wt*(1-rho)*(sigma_use1 + sigma_use2 + sigma_use3) +
eta_rw*(R1 + R2 + R3 + R12 + R13 + R23 + R123)*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) -
eta_wr*Wt*rho*(sigma_use1 + sigma_use2 + sigma_use3)
dR1 = - lambda*R1 + beta*X*R1*c1 - r_t*(1-rho)*(sigma_use2 + sigma_use3)*R1 - r_r*(1-(sigma_use2 + sigma_use3))*R1 - eta_rr*R1*rho*sigma_use2 -
eta_rr*R1*rho*sigma_use3 - eta_rw*R1*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use1
dR2 = - lambda*R2 + beta*X*R2*c2 - r_t*(1-rho)*(sigma_use1 + sigma_use3)*R2 - r_r*(1-(sigma_use1 + sigma_use3))*R2 - eta_rr*R2*rho*sigma_use1 -
eta_rr*R2*rho*sigma_use3 - eta_rw*R2*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use2
dR3 = - lambda*R3 + beta*X*R3*c3 - r_t*(1-rho)*(sigma_use1 + sigma_use2)*R3 - r_r*(1-(sigma_use1 + sigma_use2))*R3 - eta_rr*R3*rho*sigma_use1 -
eta_rr*R3*rho*sigma_use2 - eta_rw*R3*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use3
dR12 = - lambda*R12 + beta*X*R12*c12 - r_t*(1-rho)*sigma_use3*R12 - r_rr*(1-sigma_use3)*R12 - eta_rrr*R12*rho*sigma_use3 -
eta_rw*R12*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R1*rho*sigma_use2 + eta_rr*R2*rho*sigma_use1
dR13 = - lambda*R13 + beta*X*R13*c13 - r_t*(1-rho)*sigma_use2*R13 - r_rr*(1-sigma_use2)*R13 - eta_rrr*R13*rho*sigma_use2 -
eta_rw*R13*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R1*rho*sigma_use3 + eta_rr*R3*rho*sigma_use1
dR23 = - lambda*R23 + beta*X*R23*c23 - r_t*(1-rho)*sigma_use1*R23 - r_rr*(1-sigma_use1)*R23 - eta_rrr*R23*rho*sigma_use1 -
eta_rw*R23*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R2*rho*sigma_use3 + eta_rr*R3*rho*sigma_use2
dR123 = - lambda*R123 + beta*X*R123*c123 - r_rrr*R123 - eta_rw*R123*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) +
eta_rrr*rho*(sigma_use3*R12 + sigma_use2*R13 + sigma_use1*R23)
return(list(c(dX,dWt,
dR1,dR2,dR3,
dR12,dR13,dR23,
dR123)))
})
}
# Extract Sigmas for the ApproxFun Function -------------------------------
approx_sigma <- function(sigma_mat){
usage = data.frame("time" = seq(0,10000),
"PopUsage1" = c(rep(sigma_mat[1,1], 3000),
rep(sigma_mat[1,2], 365*3), rep(sigma_mat[1,3], 365*3), rep(sigma_mat[1,4], 365*3),
rep(sigma_mat[1,5], 365*3), rep(sigma_mat[1,6], 365*3), rep(sigma_mat[1,7], 10001 - (3000 + (365*3)*5))),
"PopUsage2" = c(rep(sigma_mat[2,1], 3000),
rep(sigma_mat[2,2], 365*3), rep(sigma_mat[2,3], 365*3), rep(sigma_mat[2,4], 365*3),
rep(sigma_mat[2,5], 365*3), rep(sigma_mat[2,6], 365*3), rep(sigma_mat[2,7], 10001 - (3000 + (365*3)*5))),
"PopUsage3" = c(rep(sigma_mat[3,1], 3000),
rep(sigma_mat[3,2], 365*3), rep(sigma_mat[3,3], 365*3), rep(sigma_mat[3,4], 365*3),
rep(sigma_mat[3,5], 365*3), rep(sigma_mat[3,6], 365*3), rep(sigma_mat[3,7], 10001 - (3000 + (365*3)*5))))
return(usage)
}
# ODE Wrapper Function ----------------------------------------------------
ode_wrapper <- function(times, y, parms, func, approx_sigma) {
sigma_mat = matrix(c(rep(parms[["sigma1"]], 7),
rep(parms[["sigma2"]], 7),
rep(parms[["sigma3"]], 7)),
nrow = 3, ncol = 7, byrow = T)
eff_tax <- parms[["eff_tax"]]; PED <- parms[["PED"]]
if(parms[["int_round"]] > 0 ) {
for(i in 1:parms[["int_round"]]) {
stor_sigma <- sigma_mat[,i]
sigma_mat[,(i+1):7] = c(stor_sigma[1]*(1 + ((eff_tax[1,i]*PED[1,1]) + (eff_tax[2,i]*PED[2,1]) + (eff_tax[3,i]*PED[3,1]))),
stor_sigma[2]*(1 + ((eff_tax[1,i]*PED[1,2]) + (eff_tax[2,i]*PED[2,2]) + (eff_tax[3,i]*PED[3,2]))),
stor_sigma[3]*(1 + ((eff_tax[1,i]*PED[1,3]) + (eff_tax[2,i]*PED[2,3]) + (eff_tax[3,i]*PED[3,3]))))
sigma_mat[,(i+1):7][sigma_mat[,(i+1)] < 0.01] <- 0.01
if(colSums(sigma_mat)[i+1] > 1) {
sigma_mat[,(i+1):7] <- sigma_mat[,i+1]/(sum(sigma_mat[,i+1])+0.01)
}
}
}
parms[["sigma_mat"]] <- sigma_mat
sigma_data <- approx_sigma(sigma_mat)
sigma_func1 <<- approxfun(sigma_data[,c(1,2)], rule = 2)
sigma_func2 <<- approxfun(sigma_data[,c(1,3)], rule = 2)
sigma_func3 <<- approxfun(sigma_data[,c(1,4)], rule = 2)
#Run the model
out <- data.frame(ode(y = init, func = func, times = times, parms = parms))
return(list(out, parms))
}
# Function to Aggregate Resistance ----------------------------------------
agg_func <- function(data) {
agg_data <- data.frame("time" = data$time,
"Susc" = data$X,
"WT" = data$Wt,
"R1" = data$R1 + data$R12 + data$R13 + data$R123,
"R2" = data$R2 + data$R12 + data$R23 + data$R123,
"R3" = data$R3 + data$R13 + data$R23 + data$R123)
return(agg_data)
}
# Test Parms --------------------------------------------------------------
init <- c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0)
parms = list(lambda = 1/365*(2), int_round = 1,
beta = 5, sigma1 = 0.25, sigma2 = 0.25, sigma3 = 0.25,
r_wt = 1/12, r_r = 1/10,  r_rr = 1/9,  r_rrr = 1/8,
r_t = 1/7, eta_wr = 0.3, eta_rw = 0.04,
eta_rr = 0.01, eta_rrr = 0.01,
c1 = 0.945, c2 = 0.925, c3 = 0.85,
c12 = 0.845, c13 = 0.825, c23 = 0.75,
c123 = 0.7,
PED = matrix(c(-1, 0.4, 0.4,
0.4, -1, 0.4,
0.4, 0.4, -1), #Be aware of this matrix
nrow = 3, ncol = 3, byrow = T),
eff_tax = matrix(c(0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0),
nrow = 3, ncol = 6, byrow = T),
t_n = 3000, time_between = Inf, rho = 0.05, base_tax = 0.5)
#Compute the distances for all 3 summary statistics - this section involves running the model
computeDistanceABC_ALEX <- function(fitmodel, ode_wrapper, approx_sigma, thetaparm, init.state) {
out <- ode_wrapper(y = init.state, func = fitmodel, times = seq(0, 10000), parms = thetaparm, approx_sigma)[[1]]
end_res <- tail(agg_func(out)[4:6], 1)
return(abs(c(end_res[1] - 0.4,
end_res[2] - 0.25,
end_res[3] - 0.1)))
}
computeDistanceABC_ALEX(fitmodel = amr,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
thetaparm = parms,
init.state = init)
c(end_res[1] - 0.4,
end_res[2] - 0.25,
end_res[3] - 0.1)
library("deSolve"); library("ggplot2"); library("plotly"); library("reshape2")
library("bayestestR")
rm(list=ls())
# Model -------------------------------------------------------------------
amr <- function(t, y, parms, sigma_use1, sigma_use2, sigma_use3) {
with(as.list(c(y, parms)), {
#Specify the time-varying functions
sigma_use1 <- sigma_func1(t)
sigma_use2 <- sigma_func2(t)
sigma_use3 <- sigma_func3(t)
#ODES Below
dX = lambda - lambda*X - beta*X*(Wt + R1*c1 + R2*c2 + R3*c3 + R12*c12 + R13*c13 + R23*c23 + R123*c123) +
r_wt*Wt*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + r_r*R1*(1-(sigma_use2 + sigma_use3)) + r_r*R2*(1-(sigma_use1 + sigma_use3)) + r_r*R3*(1-(sigma_use1 + sigma_use2)) +
r_rr*R12*(1-sigma_use3) + r_rr*R13*(1-sigma_use2) + r_rr*R23*(1-sigma_use1) +
r_rrr*R123 +
r_t*(1-rho)*(Wt*(sigma_use1 + sigma_use2 + sigma_use3) + R1*(sigma_use2 + sigma_use3) +
R2*(sigma_use1 + sigma_use3) + R3*(sigma_use1 + sigma_use2) +
R12*sigma_use3 + R13*sigma_use2 + R23*sigma_use1)
dWt = - lambda*Wt + beta*X*Wt - r_wt*Wt*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) - r_t*Wt*(1-rho)*(sigma_use1 + sigma_use2 + sigma_use3) +
eta_rw*(R1 + R2 + R3 + R12 + R13 + R23 + R123)*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) -
eta_wr*Wt*rho*(sigma_use1 + sigma_use2 + sigma_use3)
dR1 = - lambda*R1 + beta*X*R1*c1 - r_t*(1-rho)*(sigma_use2 + sigma_use3)*R1 - r_r*(1-(sigma_use2 + sigma_use3))*R1 - eta_rr*R1*rho*sigma_use2 -
eta_rr*R1*rho*sigma_use3 - eta_rw*R1*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use1
dR2 = - lambda*R2 + beta*X*R2*c2 - r_t*(1-rho)*(sigma_use1 + sigma_use3)*R2 - r_r*(1-(sigma_use1 + sigma_use3))*R2 - eta_rr*R2*rho*sigma_use1 -
eta_rr*R2*rho*sigma_use3 - eta_rw*R2*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use2
dR3 = - lambda*R3 + beta*X*R3*c3 - r_t*(1-rho)*(sigma_use1 + sigma_use2)*R3 - r_r*(1-(sigma_use1 + sigma_use2))*R3 - eta_rr*R3*rho*sigma_use1 -
eta_rr*R3*rho*sigma_use2 - eta_rw*R3*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_wr*rho*Wt*sigma_use3
dR12 = - lambda*R12 + beta*X*R12*c12 - r_t*(1-rho)*sigma_use3*R12 - r_rr*(1-sigma_use3)*R12 - eta_rrr*R12*rho*sigma_use3 -
eta_rw*R12*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R1*rho*sigma_use2 + eta_rr*R2*rho*sigma_use1
dR13 = - lambda*R13 + beta*X*R13*c13 - r_t*(1-rho)*sigma_use2*R13 - r_rr*(1-sigma_use2)*R13 - eta_rrr*R13*rho*sigma_use2 -
eta_rw*R13*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R1*rho*sigma_use3 + eta_rr*R3*rho*sigma_use1
dR23 = - lambda*R23 + beta*X*R23*c23 - r_t*(1-rho)*sigma_use1*R23 - r_rr*(1-sigma_use1)*R23 - eta_rrr*R23*rho*sigma_use1 -
eta_rw*R23*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) + eta_rr*R2*rho*sigma_use3 + eta_rr*R3*rho*sigma_use2
dR123 = - lambda*R123 + beta*X*R123*c123 - r_rrr*R123 - eta_rw*R123*(1 - (sigma_use1 + sigma_use2 + sigma_use3)) +
eta_rrr*rho*(sigma_use3*R12 + sigma_use2*R13 + sigma_use1*R23)
return(list(c(dX,dWt,
dR1,dR2,dR3,
dR12,dR13,dR23,
dR123)))
})
}
# Extract Sigmas for the ApproxFun Function -------------------------------
approx_sigma <- function(sigma_mat){
usage = data.frame("time" = seq(0,10000),
"PopUsage1" = c(rep(sigma_mat[1,1], 3000),
rep(sigma_mat[1,2], 365*3), rep(sigma_mat[1,3], 365*3), rep(sigma_mat[1,4], 365*3),
rep(sigma_mat[1,5], 365*3), rep(sigma_mat[1,6], 365*3), rep(sigma_mat[1,7], 10001 - (3000 + (365*3)*5))),
"PopUsage2" = c(rep(sigma_mat[2,1], 3000),
rep(sigma_mat[2,2], 365*3), rep(sigma_mat[2,3], 365*3), rep(sigma_mat[2,4], 365*3),
rep(sigma_mat[2,5], 365*3), rep(sigma_mat[2,6], 365*3), rep(sigma_mat[2,7], 10001 - (3000 + (365*3)*5))),
"PopUsage3" = c(rep(sigma_mat[3,1], 3000),
rep(sigma_mat[3,2], 365*3), rep(sigma_mat[3,3], 365*3), rep(sigma_mat[3,4], 365*3),
rep(sigma_mat[3,5], 365*3), rep(sigma_mat[3,6], 365*3), rep(sigma_mat[3,7], 10001 - (3000 + (365*3)*5))))
return(usage)
}
# ODE Wrapper Function ----------------------------------------------------
ode_wrapper <- function(times, y, parms, func, approx_sigma) {
sigma_mat = matrix(c(rep(parms[["sigma1"]], 7),
rep(parms[["sigma2"]], 7),
rep(parms[["sigma3"]], 7)),
nrow = 3, ncol = 7, byrow = T)
eff_tax <- parms[["eff_tax"]]; PED <- parms[["PED"]]
if(parms[["int_round"]] > 0 ) {
for(i in 1:parms[["int_round"]]) {
stor_sigma <- sigma_mat[,i]
sigma_mat[,(i+1):7] = c(stor_sigma[1]*(1 + ((eff_tax[1,i]*PED[1,1]) + (eff_tax[2,i]*PED[2,1]) + (eff_tax[3,i]*PED[3,1]))),
stor_sigma[2]*(1 + ((eff_tax[1,i]*PED[1,2]) + (eff_tax[2,i]*PED[2,2]) + (eff_tax[3,i]*PED[3,2]))),
stor_sigma[3]*(1 + ((eff_tax[1,i]*PED[1,3]) + (eff_tax[2,i]*PED[2,3]) + (eff_tax[3,i]*PED[3,3]))))
sigma_mat[,(i+1):7][sigma_mat[,(i+1)] < 0.01] <- 0.01
if(colSums(sigma_mat)[i+1] > 1) {
sigma_mat[,(i+1):7] <- sigma_mat[,i+1]/(sum(sigma_mat[,i+1])+0.01)
}
}
}
parms[["sigma_mat"]] <- sigma_mat
sigma_data <- approx_sigma(sigma_mat)
sigma_func1 <<- approxfun(sigma_data[,c(1,2)], rule = 2)
sigma_func2 <<- approxfun(sigma_data[,c(1,3)], rule = 2)
sigma_func3 <<- approxfun(sigma_data[,c(1,4)], rule = 2)
#Run the model
out <- data.frame(ode(y = init, func = func, times = times, parms = parms))
return(list(out, parms))
}
# Function to Aggregate Resistance ----------------------------------------
agg_func <- function(data) {
agg_data <- data.frame("time" = data$time,
"Susc" = data$X,
"WT" = data$Wt,
"R1" = data$R1 + data$R12 + data$R13 + data$R123,
"R2" = data$R2 + data$R12 + data$R23 + data$R123,
"R3" = data$R3 + data$R13 + data$R23 + data$R123)
return(agg_data)
}
# Test Parms --------------------------------------------------------------
init <- c(X = 0.99, Wt = 1-0.99, R1 = 0, R2 = 0, R3 = 0,
R12 = 0, R13 = 0, R23 = 0,
R123 = 0)
parms = list(lambda = 1/365*(2), int_round = 1,
beta = 5, sigma1 = 0.25, sigma2 = 0.25, sigma3 = 0.25,
r_wt = 1/12, r_r = 1/10,  r_rr = 1/9,  r_rrr = 1/8,
r_t = 1/7, eta_wr = 0.3, eta_rw = 0.04,
eta_rr = 0.01, eta_rrr = 0.01,
c1 = 0.945, c2 = 0.925, c3 = 0.85,
c12 = 0.845, c13 = 0.825, c23 = 0.75,
c123 = 0.7,
PED = matrix(c(-1, 0.4, 0.4,
0.4, -1, 0.4,
0.4, 0.4, -1), #Be aware of this matrix
nrow = 3, ncol = 3, byrow = T),
eff_tax = matrix(c(0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0),
nrow = 3, ncol = 6, byrow = T),
t_n = 3000, time_between = Inf, rho = 0.05, base_tax = 0.5)
#Compute the distances for all 3 summary statistics - this section involves running the model
computeDistanceABC_ALEX <- function(fitmodel, ode_wrapper, approx_sigma, thetaparm, init.state) {
out <- ode_wrapper(y = init.state, func = fitmodel, times = seq(0, 10000), parms = thetaparm, approx_sigma)[[1]]
end_res <- as.numeric(tail(agg_func(out)[4:6], 1))
return(abs(c(end_res[1] - 0.4,
end_res[2] - 0.25,
end_res[3] - 0.1)))
}
computeDistanceABC_ALEX(fitmodel = amr,
ode_wrapper = ode_wrapper,
approx_sigma = approx_sigma,
thetaparm = parms,
init.state = init)
rtmvnorm
library(rtmvnorm)
library(tmvnorm)
library("tmvtnorm")
